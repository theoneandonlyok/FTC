package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.Servo;

@TeleOp
public class ItkanInnovatorsTeleOpTEST extends LinearOpMode {
    DcMotor in = null;
    DcMotor out1 = null;
    DcMotor out2 = null;
    DcMotor fl, fr, br, bl;

@Override
public void runOpMode() {


    fl = hardwareMap.get(DcMotor.class, "fl");
    fr = hardwareMap.get(DcMotor.class, "fr");
    bl = hardwareMap.get(DcMotor.class, "bl");
    br = hardwareMap.get(DcMotor.class, "br");

    in = hardwareMap.get(DcMotor.class, "in");

    out1 = hardwareMap.get(DcMotor.class, "out1");
    out2 = hardwareMap.get(DcMotor.class, "out2");

    fl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    fr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    br.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    bl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

    br.setDirection(DcMotorSimple.Direction.REVERSE);
    fr.setDirection(DcMotorSimple.Direction.REVERSE);

    out1.setDirection(DcMotorSimple.Direction.REVERSE);

    telemetry.addData("Status", "Initialized");
    telemetry.update();

    double inPower = 0.0;
    boolean lb_prev = false, rb_prev = false;

    waitForStart();

    while (opModeIsActive()) {
        telemetry.addData("Status", "Running");
        telemetry.update();
        
        // out1.setPower(-0.2);
        // out2.setPower(-0.2);

        double motorPowerScale = 1.0;
        // DRIVE (Forward/Backward) typically mapped to left stick Y-axis
        double drive = -gamepad2.left_stick_x; // Negative because Y is usually inverted on gamepads
        // STRAFE (Left/Right) typically mapped to left stick X-axis
        double strafe = gamepad2.left_stick_y;
        // TURN (Rotation) typically mapped to right stick X-axis
        double turn = -gamepad2.right_stick_x;

        // Mecanum Drive Power Calculations
        // Note: The signs for 'drive' and 'strafe' are motor-dependent.
        // The signs for 'turn' are the critical fix for rotation.

        // Left Side Motors (FL & BL)
        double flPower = (drive + strafe + turn) * motorPowerScale; // FL: +turn
        double blPower = (drive - strafe + turn) * motorPowerScale; // BL: +turn

        // Right Side Motors (FR & BR)
        double frPower = (drive - strafe - turn) * motorPowerScale; // FR: -turn
        double brPower = (drive + strafe - turn) * motorPowerScale; // BR: -turn

        fr.setPower(frPower);
        fl.setPower(flPower);
        br.setPower(brPower);
        bl.setPower(blPower);
        // (You may need to reverse the sign of the 'strafe' or 'drive' components 
        // depending on the physical orientation of your motors and wheels.)
        
        if(gamepad1.rightStickButtonWasPressed()){
            motorPowerScale = 0.5;
        } else if (gamepad1.rightStickButtonWasReleased()){
            motorPowerScale = 1;
        }

        if(gamepad1.right_trigger > 0.05){
            out1.setPower(0.6);
            out2.setPower(0.6);
        } else {
            out1.setPower(0);
            out2.setPower(0);
        }
        
        if(gamepad1.left_trigger > 0.05){
            in.setPower(1);
        } else {
            in.setPower(0);
        }

        if(gamepad1.a) {
            inPower = 1.0;
        } else if (gamepad1.x) {
            inPower = 0.0;
        }
        if(gamepad1.b) {
            out1.setPower(0.75);
            out2.setPower(0.75);
        } else if (gamepad1.y) {
            out1.setPower(0);
            out2.setPower(0);
        } else if(gamepad1.left_bumper && lb_prev == false){
            inPower -= 0.5;
        } else if(gamepad1.right_bumper && rb_prev == false){
            inPower += 0.5;
        }

        if(inPower > 1){
            inPower = 1;
        }
        if(inPower <= 0){
            inPower = 0;
        }

        lb_prev = gamepad1.left_bumper;
        rb_prev = gamepad1.right_bumper;

        if (gamepad1.dpadUpWasPressed()){
            in.setDirection(DcMotorSimple.Direction.REVERSE);
            inPower = 1;
        } else if (gamepad1.dpadUpWasReleased()){
            in.setDirection(DcMotorSimple.Direction.FORWARD);
            inPower = 0;
        }

        // if (gamepad1.dpadDown()){
        //     out1.setPower(-0.5);
        //     out2.setPower(-0.5);
        

        in.setPower(inPower);
    }
}
