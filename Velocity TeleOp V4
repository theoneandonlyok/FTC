package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
@TeleOp
public class VelocityV4 extends LinearOpMode {
    DcMotor in = null;
    DcMotor tran = null;
    DcMotorEx out1 = null;
    DcMotorEx out2 = null;
    DcMotor fl, fr, br, bl;
    
    double powerConvert = 1500; // Default idle
    double targetVelocity = 0.0;
    double velocityBuffer = 150.0; // Allowable overshoot

    @Override
    public void runOpMode() {

        // --- Hardware Mapping ---
        fl = hardwareMap.get(DcMotor.class, "fl");
        fr = hardwareMap.get(DcMotor.class, "fr");
        bl = hardwareMap.get(DcMotor.class, "bl");
        br = hardwareMap.get(DcMotor.class, "br");
        in = hardwareMap.get(DcMotor.class, "in");
        tran = hardwareMap.get(DcMotor.class, "tran");
        out1 = hardwareMap.get(DcMotorEx.class, "out1");
        out2 = hardwareMap.get(DcMotorEx.class, "out2");

        // --- Motor Setup ---
        fl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        fr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        br.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        bl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        br.setDirection(DcMotorSimple.Direction.REVERSE);
        fr.setDirection(DcMotorSimple.Direction.REVERSE);

        out1.setDirection(DcMotorSimple.Direction.REVERSE);
        out1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        out2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        telemetry.addData("Status", "Initialized");
        telemetry.update();

        double motorPowerScale = 1.0;

        waitForStart();

        while (opModeIsActive()) {
            
            // --- 1. DRIVETRAIN LOGIC ---
            if(gamepad2.right_stick_button){
                motorPowerScale = 0.5;
            } else {
                motorPowerScale = 1.0;
            }

            double drive = -gamepad2.left_stick_y; 
            double strafe = gamepad2.left_stick_x;
            double turn = -gamepad2.right_stick_x * 0.65;

            fl.setPower((drive + strafe + turn) * motorPowerScale);
            bl.setPower((drive - strafe + turn) * motorPowerScale);
            fr.setPower((drive - strafe - turn) * motorPowerScale);
            br.setPower((drive + strafe - turn) * motorPowerScale);

            // --- 2. SHOOTER VELOCITY CONTROL ---
            // If no firing buttons are pressed, it defaults to the idle target
            targetVelocity = 0.56 * 1500; 

            if (gamepad2.dpad_down) {
                targetVelocity = -3000; 
            } else if (gamepad2.right_trigger > 0.05) {
                targetVelocity = 0.56 * 2250;
            } else if (gamepad2.b) {
                targetVelocity = 0.56 * 2900;
            } else if (gamepad2.y) {
                targetVelocity = 0;
            } else if (gamepad2.dpad_up) {
                 targetVelocity = -500; 
            }

            out1.setVelocity(targetVelocity);
            out2.setVelocity(targetVelocity);
            
            double currentVel = out1.getVelocity();

            // --- 3. INTAKE & TRANSFER LOGIC ---
            double inPower = 0.0;
            double tranPower = 0.0;

            if (gamepad2.dpad_down || gamepad2.dpad_up) {
                inPower = -1.0;
                tranPower = -1.0;
            } 
            else if (gamepad2.a && targetVelocity > 1100) {
                // Check if we are within the "Goldilocks" zone (Fast enough AND not overshooting)
                boolean isFastEnough = currentVel > (targetVelocity * 0.95);
                boolean isNotOvershooting = currentVel < (targetVelocity + velocityBuffer);

                if (isFastEnough && isNotOvershooting) {
                    inPower = 0.7;
                    tranPower = 1.0;
                    telemetry.addLine("READY TO FIRE");
                } else {
                    inPower = 0.0;
                    tranPower = 0.0;
                    if (!isFastEnough) telemetry.addLine("Status: Spooling Up...");
                    if (!isNotOvershooting) telemetry.addLine("Status: Overshoot - Waiting...");
                }
            }
            else if (gamepad2.left_trigger > 0.05 || gamepad2.left_trigger > 0.05) {
                // Manual intake now works even if shooter is ramping
                inPower = 1.0;
                tranPower = 0.0;
            }
            else if (gamepad2.x) {
                inPower = 0.0;
                tranPower = 0.0;
            }

            in.setPower(inPower);
            tran.setPower(tranPower);

            // --- 4. TELEMETRY ---
            telemetry.addData("Target", targetVelocity);
            telemetry.addData("Current", (int)currentVel);
            telemetry.addData("Shooter Status", (targetVelocity > 1100) ? "Active" : "Idle");
            telemetry.update();
        }
    }
}
