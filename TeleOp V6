package org.firstinspires.ftc.teamcode;

import com.qualcomm.hardware.limelightvision.LLResult;
import com.qualcomm.hardware.limelightvision.LLResultTypes;
import com.qualcomm.hardware.limelightvision.Limelight3A;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.Servo;

@TeleOp(name = "A TeleOp", group = "Linear Opmode")
public class TeleOp V6 extends LinearOpMode {
    // --- Existing Hardware ---
    DcMotor in, tran;
    DcMotorEx out1, out2;
    DcMotor fl, fr, br, bl;
    Servo gate;

    // --- Limelight & Align Variables ---
    private Limelight3A limelight;
    enum Alliance {
        BLUE(20), RED(24);
        private final int goalApriltag;
        Alliance(int id) { this.goalApriltag = id; }
        public int getGoalApriltag() { return goalApriltag; }
    }
    Alliance matchAlliance = Alliance.BLUE;
    int goalApriltag = 20;

    // Align Constants
    private final double ALIGN_TOLERANCE_DEG = 1.0;
    private final double TURN_KP = -0.01;
    private final double MIN_TURN_POWER = 0.1;

    // Shooter Variables
    double targetVelocity = 0.0;
    double velocityBuffer = 100.0;
    double unblocked_position = 1.0;
    double blocked_positon = 0.0;
    double gate_position = 0.0;

    @Override
    public void runOpMode() {
        // --- Hardware Mapping ---
        fl = hardwareMap.get(DcMotor.class, "fl");
        fr = hardwareMap.get(DcMotor.class, "fr");
        bl = hardwareMap.get(DcMotor.class, "bl");
        br = hardwareMap.get(DcMotor.class, "br");
        in = hardwareMap.get(DcMotor.class, "in");
        tran = hardwareMap.get(DcMotor.class, "tran");
        out1 = hardwareMap.get(DcMotorEx.class, "out1");
        out2 = hardwareMap.get(DcMotorEx.class, "out2");
        gate = hardwareMap.get(Servo.class, "gate");

        // --- Limelight Init ---
        limelight = hardwareMap.get(Limelight3A.class, "limelight");
        limelight.setPollRateHz(10);
        limelight.start();
        limelight.pipelineSwitch(0);

        // --- Motor Setup ---
        fl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        fr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        bl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        br.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        br.setDirection(DcMotorSimple.Direction.REVERSE);
        fr.setDirection(DcMotorSimple.Direction.REVERSE);

        out1.setDirection(DcMotorSimple.Direction.REVERSE);
        out1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        out2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // --- Alliance Selection Loop ---
        while (!isStarted() && !isStopRequested()) {
            if (gamepad1.b || gamepad2.b) matchAlliance = Alliance.RED;
            if (gamepad1.x || gamepad2.x) matchAlliance = Alliance.BLUE;

            telemetry.addData("Alliance (B=Red, X=Blue)", matchAlliance.name());
            telemetry.addData("Tracking Tag", matchAlliance.getGoalApriltag());
            telemetry.update();
        }

        goalApriltag = matchAlliance.getGoalApriltag();
        waitForStart();

        while (opModeIsActive()) {
            // --- 1. LIMELIGHT DATA ---
            LLResult result = limelight.getLatestResult();
            double tx = 0;
            boolean hasTarget = false;

            if (result != null && result.isValid()) {
                if (result.getFiducialResults() != null && !result.getFiducialResults().isEmpty()) {
                    for (LLResultTypes.FiducialResult fiducial : result.getFiducialResults()) {
                        if (fiducial.getFiducialId() == goalApriltag) {
                            hasTarget = true;
                            tx = fiducial.getTargetXDegrees();
                            break;
                        }
                    }
                }
            }

            // --- 2. DRIVETRAIN LOGIC ---
            double motorPowerScale = 1.0;
            double drive = -gamepad1.left_stick_y;
            double strafe = -gamepad1.left_stick_x;
            double turn = -gamepad1.right_stick_x;

            // Auto-align override: If shooting and target found, override turn
            boolean isShooting = (gamepad2.right_bumper || gamepad2.left_bumper);

            if (hasTarget && isShooting) {
                double headingError = tx + 1; // +1 offset from TEST2
                if (Math.abs(headingError) > ALIGN_TOLERANCE_DEG) {
                    // Calculate auto-turn power
                    turn = -(headingError * TURN_KP - MIN_TURN_POWER * Math.signum(headingError));
                } else {
                    turn = 0;
                }
            }

            fl.setPower((drive + strafe + turn) * motorPowerScale);
            bl.setPower((drive - strafe + turn) * motorPowerScale);
            fr.setPower((drive - strafe - turn) * motorPowerScale);
            br.setPower((drive + strafe - turn) * motorPowerScale);

            // --- 3. SHOOTER VELOCITY CONTROL ---
            if (gamepad2.right_bumper) {
                targetVelocity = 1400;
            } else if (gamepad2.left_bumper) {
                targetVelocity = 1800;//tune these velocitys
            } else if (gamepad2.y) {
                targetVelocity = 0;
            } else {
                targetVelocity = 1000; // Default Idle
            }

            out1.setVelocity(targetVelocity);
            out2.setVelocity(targetVelocity);
            double currentVel = out1.getVelocity();

            // --- 4. INTAKE & TRANSFER LOGIC ---
            double inPower = 0.0;
            double tranPower = 0.0;

            if (gamepad1.left_trigger > 0.1 || gamepad2.left_trigger > 0.1) {
                inPower = -1.0;
                tranPower = -1.0;
            }
            else if (gamepad2.a && targetVelocity > 1100) {
                boolean isFastEnough = currentVel > (targetVelocity - velocityBuffer);
                boolean isNotOvershooting = currentVel < (targetVelocity + velocityBuffer);

                if (isFastEnough && isNotOvershooting) {
                    inPower = 1.0;
                    tranPower = 1.0;
                    gate_position = unblocked_position;
                }
            }
            else if (gamepad1.right_trigger > 0.05 || gamepad2.right_trigger > 0.05) {
                inPower = 1.0;
                tranPower = 0.6;
            }
            else {
                tranPower = 0.0;
                inPower = 0.0;
                gate_position = blocked_positon;
            }

            in.setPower(inPower);
            tran.setPower(tranPower);
            gate.setPosition(gate_position);

            // --- 5. TELEMETRY ---
            telemetry.addData("Alliance", matchAlliance.name());
            telemetry.addData("Target Tag", goalApriltag);
            telemetry.addData("Has Target", hasTarget);
            telemetry.addData("Target Vel", targetVelocity);
            telemetry.addData("Current Vel", (int)currentVel);
            telemetry.update();
        }
    }
}
