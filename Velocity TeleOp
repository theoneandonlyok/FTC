package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.Servo;

@TeleOp
public class NoahTest extends LinearOpMode {
    DcMotor in = null;
    DcMotorEx out1 = null;
    DcMotorEx out2 = null;
    DcMotor fl, fr, br, bl;
    double powerConvert = 2000; 
    double targetVelocity;
@Override
public void runOpMode() {


    fl = hardwareMap.get(DcMotor.class, "fl");
    fr = hardwareMap.get(DcMotor.class, "fr");
    bl = hardwareMap.get(DcMotor.class, "bl");
    br = hardwareMap.get(DcMotor.class, "br");

    in = hardwareMap.get(DcMotor.class, "in");

    out1 = hardwareMap.get(DcMotorEx.class, "out1");
    out2 = hardwareMap.get(DcMotorEx.class, "out2");

    fl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    fr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    br.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    bl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

    br.setDirection(DcMotorSimple.Direction.REVERSE);
    fr.setDirection(DcMotorSimple.Direction.REVERSE);

    out1.setDirection(DcMotorSimple.Direction.REVERSE);
    out1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

    telemetry.addData("Status", "Initialized");
    telemetry.update();

    double inPower = 0.0;
    boolean lb_prev = false, rb_prev = false;

    waitForStart();

    while (opModeIsActive()) {
        telemetry.addData("Status", "Running");
        telemetry.update();
        
        // out1.setPower(-0.2);
        // out2.setPower(-0.2);

        double motorPowerScale = 1.0;
        // DRIVE (Forward/Backward) typically mapped to left stick Y-axis
        double drive = gamepad2.left_stick_x; // Negative because Y is usually inverted on gamepads
        // STRAFE (Left/Right) typically mapped to left stick X-axis
        double strafe = -gamepad2.left_stick_y;
        // TURN (Rotation) typically mapped to right stick X-axis
        double turn = -gamepad2.right_stick_x*0.66;

        // Mecanum Drive Power Calculations
        // Note: The signs for 'drive' and 'strafe' are motor-dependent.
        // The signs for 'turn' are the critical fix for rotation.

        // Left Side Motors (FL & BL)
        double flPower = (drive + strafe + turn) * motorPowerScale; // FL: +turn
        double blPower = (drive - strafe + turn) * motorPowerScale; // BL: +turn

        // Right Side Motors (FR & BR)
        double frPower = (drive - strafe - turn) * motorPowerScale; // FR: -turn
        double brPower = (drive + strafe - turn) * motorPowerScale; // BR: -turn

        fr.setPower(frPower);
        fl.setPower(flPower);
        br.setPower(brPower);
        bl.setPower(blPower);
        // (You may need to reverse the sign of the 'strafe' or 'drive' components 
        // depending on the physical orientation of your motors and wheels.)
        
        if(gamepad1.rightStickButtonWasPressed()){
            motorPowerScale = 0.5;
        } else if (gamepad1.rightStickButtonWasReleased()){
            motorPowerScale = 1;
        }

        if(gamepad1.right_trigger > 0.05){
            out1.setVelocity(0.56* powerConvert);
            out2.setVelocity(0.56* powerConvert);
            targetVelocity = 0.56* powerConvert;
            // if (targetVelocity<out1.getVelocity()){
            //     inPower = 0.7;
            //     telemetry.addLine("ready");
            //     telemetry.update();
            // } else {
            //     inPower = 0.0;
            // }
        } else {
            out1.setVelocity(0);
            out2.setVelocity(0);
        }
        
        if(gamepad1.left_trigger > 0.3){
            inPower = 0.5;
        }
        if(gamepad1.a) {
            if (out1.getVelocity()<targetVelocity){
                inPower = 0.0;
            } else {
                inPower = 1.0;
            }
        } else if (gamepad1.x) {
            inPower = 0.0;
        } else if (gamepad1.left_trigger > 0.05 || gamepad2.right_trigger > 0.1){
            inPower = 0.5;
        } else if (gamepad1.dpad_up){
            inPower = -1;
            out1.setVelocity(-3000);
        }else {
            inPower = 0.0;
        }
        if(gamepad1.b) {
            out1.setVelocity(0.75 * powerConvert);
            out2.setVelocity(0.75 * powerConvert);
            targetVelocity = 0.75* powerConvert;
        } else if (gamepad1.y) {
            out1.setVelocity(0);
            out2.setVelocity(0);
            targetVelocity = -1000;
        } else if(gamepad1.left_bumper && lb_prev == false){
            inPower -= 0.5;
        } else if(gamepad1.right_bumper && rb_prev == false){
            inPower += 0.5;
        }

        lb_prev = gamepad1.left_bumper;
        rb_prev = gamepad1.right_bumper;

        

        // if (gamepad1.dpadDown()){
        //     out1.setPower(-0.5);
        //     out2.setPower(-0.5);
        

        in.setPower(inPower);
        telemetry.addData("out 1 vel", out1.getVelocity());
    }
}
}
